#version 440

layout(binding = 0, rgba32f) uniform image2D framebuffer;
// wrriten by compute shader

layout (local_size_x = 8, local_size_y = 8) in;

uniform vec3 triangles[500];
uniform vec3 spheres[500];

uniform vec3 eye;
uniform vec3 ray00;
uniform vec3 ray10;
uniform vec3 ray01;
uniform vec3 ray11;

// camera specification
// ray will be interpolated for each pixel

struct triangle {
    vec3 points[3];
};

struct sphere {
    vec3 pos;
    float r;
};

struct hitinfo {
    vec2 lambda;
    int idx;
};

vec2 intersect_triangle(vec3 origin, vec3 dir, const triangle t)
{
    // TODO : Not implemented
    return vec2(0.0, 0.0);
}

vec2 intersect_sphere(vec3 origin, vec3 dir, const sphere s)
{
    // TODO : Not implemented
    return vec2(0.0, 0.0);
}

bool intersect_objects(vec3 origin, vec3 dir, out hitinfo info)
{
    return true;
}

vec4 trace(vec3 origin, vec3 dir)
{
    hitinfo info;
    if (intersect_objects(origin, dir, info)) {
        vec4 gray = vec4(info.idx/10.0 + 0.8);
        return vec4(gray.rgb, 1.0);
    }
    return vec4(0.0, 0.0, 0.0, 0.0);
}

void main() 
{
    // get index in global work group i.e x,y position
    ivec2 pixel_coords = ivec2(gl_GlobalInvocationID.xy);
    vec4 pixel = vec4(1.0, 1.0, 0.0, 1.0);

    
    float max_x = 5.0;
    float max_y = 5.0;
    ivec2 dims = imageSize(framebuffer); // fetch image dimensions
    float x = (float(pixel_coords.x * 2 - dims.x) / dims.x);
    float y = (float(pixel_coords.y * 2 - dims.y) / dims.y);
    vec3 ray_o = vec3(x * max_x, y * max_y, 0.0);
    vec3 ray_d =  vec3(0.0, 0.0, -1.0); // ortho

    vec3 sphere_c = vec3(0.0, 0.0, -10.0);
    float sphere_r = 1.0;

    vec3 omc = ray_o - sphere_c;
    float b = dot(ray_d, omc);
    float c = dot(omc, omc) - sphere_r * sphere_r;
    float bsqmc = b * b - c;
    // hit one or both sides
    if (bsqmc >= 0.0) {
      pixel = vec4(0.4, 0.4, 1.0, 1.0);
    }
    
    imageStore(framebuffer, pixel_coords, pixel);
}

// Reference : https://github.com/LWJGL/lwjgl3-wiki/wiki/2.6.1.-Ray-tracing-with-OpenGL-Compute-Shaders-%28Part-I%29

/*

ivec2 pix = ivec2(gl_GlobalInvocationID.xy);
ivec2 size = imageSize(framebuffer);
if (pix.x >= size.x || pix.y >= size.y) return;

vec2 pos = vec2(pix) / vec2(size.x, size.y);
vec3 dir = mix(mix(ray00, ray01, pos.y), mix(ray10, ray11, pos.y), pos.x);
vec4 color = trace(eye, dir);
imageStore(framebuffer, pix, color);
    
*/