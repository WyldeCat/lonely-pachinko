#version 440

#define MAX_NUM_MATERIALS 8
#define MAX_NUM_VERTICES  512
#define MAX_NUM_TRIANGLES 512
#define MAX_NUM_SPHERES   512

struct light {
    vec4 ambient;
    vec4 specular;
    vec4 diffuse;
    vec3 pos;
};

struct material {
    vec4 ambient;
    vec4 diffuse;
    vec4 specular;
};

struct vertex {
    float pos[3];
    float normal[3];
};

struct triangle {
    int index[4];
};

struct sphere {
    float pos[3];
    float r;
};

struct hitinfo {
    vec3 point;
    vec3 normal;
    int material_idx;
    int type;
    float dist;
};

layout(binding = 0, rgba32f) uniform image2D framebuffer;
// wrriten by compute shader

layout (local_size_x = 1, local_size_y = 1) in;

layout(binding = 1, std430) buffer vertices
{
    vertex vertices_[MAX_NUM_VERTICES];
    // TODO : Add size
};

layout(binding = 2, std430) buffer triangles
{
    triangle triangles_[MAX_NUM_VERTICES];
};

layout(binding = 3, std430) buffer spheres
{
    sphere spheres_[MAX_NUM_VERTICES];
};

uniform int num_vertices;
uniform int num_triangles;
uniform int num_spheres;

uniform vec3 eye;
uniform vec3 ray00;
uniform vec3 ray10;
uniform vec3 ray01;
uniform vec3 ray11;

light light1;
material materials[5];

bool intersect_triangle(vec3 origin, vec3 dir, const triangle t, out vec3 p)
{
    // TODO : Need to consider front and back

    vec3 e1, e2, h, s, q;
    float a, f, u, v, tmp;
    bool is_intersect = true;

    e1 = vec3(vertices_[t.index[1]].pos[0] - vertices_[t.index[0]].pos[0], 
              vertices_[t.index[1]].pos[1] - vertices_[t.index[0]].pos[1],
              vertices_[t.index[1]].pos[2] - vertices_[t.index[0]].pos[2]);

    e2 = vec3(vertices_[t.index[2]].pos[0] - vertices_[t.index[0]].pos[0], 
              vertices_[t.index[2]].pos[1] - vertices_[t.index[0]].pos[1],
              vertices_[t.index[2]].pos[2] - vertices_[t.index[0]].pos[2]);

    h = cross(dir, e2);
    a = dot(e1, h);

    if (a > -0.00001 && a < 0.00001) return false;
    
    f = 1/a;
    s = vec3(origin[0] - vertices_[t.index[0]].pos[0], 
             origin[1] - vertices_[t.index[0]].pos[1],
             origin[2] - vertices_[t.index[0]].pos[2]);

    u = f * dot(s, h);

    if (u < 0.0 || u > 1.0) return false;
    
    q = cross(s, e1);
    v = f * dot(dir, q);

    if (v < 0.0 || u + v > 1.0) return false;

    tmp = f * dot(e2, q);

    if (tmp > 0.00001) {
        p = origin + tmp * dir;
        return true;
    }

    return false;
}

bool intersect_sphere(vec3 origin, vec3 dir, const sphere s, out vec3 p)
{
    // have to solve 
    // t^2 + 2 * dir * ( origin - s.pos ) * t 
    // + ( origin - s.pos ) ^ 2 - s.r ^ 2

    vec3 op = 
        vec3(origin.x - s.pos[0], origin.y - s.pos[1], origin.z - s.pos[2]);

    float b = 2 * dot(dir, op);
    float c = pow(length(op), 2) - pow(s.r, 2);
    float discr = b * b - 4 * c;
    float x0, x1;


    if (discr < 0) return false;

    if (discr == 0) x0 = x1 = -0.5 * b;
    else if (b > 0) {
        float q = -0.5 * (b + sqrt(discr));
        x0 = q;
        x1 = c / q;
    }
    else {
        float q = -0.5 * (b - sqrt(discr));
        x0 = q;
        x1 = c / q;
    }

    if (x0 < x1 && x0 >= 0) {
        p = origin + x0 * dir;
        return true;
    }
    else if (x1 < x0 && x1 >= 0) {
        p = origin + x1 * dir;
        return true;
    }
    return false;
}

bool intersect_objects(vec3 origin, vec3 dir, out hitinfo info)
{
    int i;
    vec3 p;
    bool exist = false;
    float min_dist = 999999999;

    for (i = 0; i < num_triangles; i++) {
        if (intersect_triangle(origin, dir, triangles_[i], p)) {
            float dist = distance(origin, p);
            if (dist > 0.001 && min_dist > dist)
            {
                min_dist = dist;
                info.point = p;
                info.type = 0;
                info.dist = min_dist;
                info.material_idx = triangles_[i].index[3];
                exist = true;
            }
        }
    }

    for (i = 0; i < num_spheres; i++) {
        if (intersect_sphere(origin, dir, spheres_[i], p)) {
            float dist = distance(origin, p);
            if (dist > 0.001 && min_dist > dist) 
            {
                min_dist = dist;
                info.point = p;
                info.type = 1;
                info.dist = min_dist;
                info.material_idx = 2;
                exist = true;
            }
        }
    }

    return exist;
}

vec4 dott(vec4 a, vec4 b) 
{
    return vec4(a[0]*b[0], a[1]*b[1], a[2]*b[2], a[3]*b[3]);
}

vec4 trace(vec3 origin, vec3 dir)
{
    hitinfo info;
    hitinfo info2;
    info2.material_idx = 0;
    int i, count = 0;
    vec4 result = vec4(0.0, 0.0, 0.0, 0.0);

    if (intersect_objects(origin, dir, info)) {
        if (info.type == 0) {
            result += dott(light1.ambient,
                materials[info.material_idx].ambient);
            intersect_objects(info.point, normalize(vec3(0, 8, 0) - info.point),
                info2);
            if (info2.dist >= distance(info.point, vec3(0, 8, 0))) {
                result += dott(light1.diffuse,
                    materials[info.material_idx].diffuse);
            }
        }
        else {
            result += dott(light1.ambient,
                materials[2].ambient);
            intersect_objects(info.point, normalize(vec3(0, 8, 0) - info.point),
                info2);
            if (info2.dist >= distance(info.point, vec3(0, 8, 0))) {
                result += dott(light1.diffuse,
                    materials[2].diffuse);
            }
        }
    }

    return result;
}

void main()
{
    
    light1.pos = vec3(0, 10, 0);
    light1.ambient = vec4(1, 1, 1, 1);
    light1.diffuse = vec4(1, 1, 1, 1);
    light1.specular = vec4(1, 1, 1, 1);

    materials[0].ambient = vec4(0.1, 0.0, 0.0, 1.0);
    materials[0].diffuse = vec4(0.5, 0.0, 0.0, 1.0);
    materials[1].ambient = vec4(0.0, 0.1, 0.0, 1.0);
    materials[1].diffuse = vec4(0.0, 0.5, 0.0, 1.0);
    materials[2].ambient = vec4(0.0, 0.0, 0.1, 1.0);
    materials[2].diffuse = vec4(0.0, 0.0, 0.5, 1.0);
    materials[3].diffuse = vec4(0, 0, 0, 0);
    materials[3].ambient = vec4(0, 0, 0, 0);

    // get index in global work group i.e x,y position
    ivec2 pixel_coords = ivec2(gl_GlobalInvocationID.xy);
    vec2 pos = pixel_coords / 1024.0;
    vec3 dir = normalize(mix(mix(ray00, ray01, pos.y), mix(ray10, ray11, pos.y), pos.x));
    vec4 pixel;

    pixel = trace(eye, dir);

    imageStore(framebuffer, pixel_coords, pixel);
}

// Reference : 
// https://github.com/LWJGL/lwjgl3-wiki/wiki/2.6.1.-Ray-tracing-with-OpenGL-Compute-Shaders-%28Part-I%29