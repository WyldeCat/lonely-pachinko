#version 440

#define MAX_NUM_MATERIALS 8
#define MAX_NUM_VERTICES  256
#define MAX_NUM_TRIANGLES 256
#define MAX_NUM_SPHERES   256

struct material {
    vec4 ambient;
    vec4 diffuse;
    vec4 specular;
};

struct vertex {
    float pos[3];
    float normal[3];
};

struct triangle {
    int index[4];
};

struct sphere {
    float pos[3];
    float r;
};

struct hitinfo {
    vec3 point;
    int idx;
    int material_idx;
    int type;
};

layout(binding = 0, rgba32f) uniform image2D framebuffer;
// wrriten by compute shader

layout (local_size_x = 1, local_size_y = 1) in;

layout(binding = 1, std430) buffer vertices
{
    vertex vertices_[MAX_NUM_VERTICES];
    // TODO : Add size
};

layout(binding = 2, std430) buffer triangles
{
    triangle triangles_[MAX_NUM_VERTICES];
};

layout(binding = 3, std430) buffer spheres
{
    sphere spheres_[MAX_NUM_VERTICES];
};

uniform int num_vertices;
uniform int num_triangles;
uniform int num_spheres;

uniform vec3 eye;
uniform vec3 ray00;
uniform vec3 ray10;
uniform vec3 ray01;
uniform vec3 ray11;

material materials[3];

bool intersect_triangle(vec3 origin, vec3 dir, const triangle t, out vec3 p)
{
    // TODO : Need to consider front and back

    vec3 e1, e2, h, s, q;
    float a, f, u, v, tmp;
    bool is_intersect = true;

    e1 = vec3(vertices_[t.index[1]].pos[0] - vertices_[t.index[0]].pos[0], 
              vertices_[t.index[1]].pos[1] - vertices_[t.index[0]].pos[1],
              vertices_[t.index[1]].pos[2] - vertices_[t.index[0]].pos[2]);

    e2 = vec3(vertices_[t.index[2]].pos[0] - vertices_[t.index[0]].pos[0], 
              vertices_[t.index[2]].pos[1] - vertices_[t.index[0]].pos[1],
              vertices_[t.index[2]].pos[2] - vertices_[t.index[0]].pos[2]);

    h = cross(dir, e2);
    a = dot(e1, h);

    if (a > -0.00001 && a < 0.00001) return false;
    
    f = 1/a;
    s = vec3(origin[0] - vertices_[t.index[0]].pos[0], 
             origin[1] - vertices_[t.index[0]].pos[1],
             origin[2] - vertices_[t.index[0]].pos[2]);

    u = f * dot(s, h);

    if (u < 0.0 || u > 1.0) return false;
    
    q = cross(s, e1);
    v = f * dot(dir, q);

    if (v < 0.0 || u + v > 1.0) return false;

    tmp = f * dot(e2, q);

    if (tmp > 0.00001) {
        p = origin + tmp * dir;
        return true;
    }

    return false;
}

bool intersect_sphere(vec3 origin, vec3 dir, const sphere s, out vec3 p)
{
    // TODO : Not implemented

    return true;
}

bool intersect_objects(vec3 origin, vec3 dir, out hitinfo info)
{
    int i;
    vec3 p;
    bool exist = false;
    float min_dist = 999999999;

    for (i = 0; i < num_triangles; i++) {
        if (intersect_triangle(origin, dir, triangles_[i], p)) {
            if (min_dist > distance(origin, p))
            {
                min_dist = distance(origin, p);
                info.point = p;
                info.idx = i;
                info.type = 0;
                info.material_idx = triangles_[i].index[3];
                exist = true;
            }
        }
    }

    for (i = 0; i < num_spheres; i++) {
        if (intersect_sphere(origin, dir, spheres_[i], p)) {
            if (min_dist > distance(origin, p)) 
            {
                min_dist = distance(origin, p);
                info.point = p;
                info.idx = i;
                info.type = 1;
                info.material_idx = 2;
                exist = true;
            }
        }
    }
    return exist;
}

vec4 trace(vec3 origin, vec3 dir)
{
    hitinfo info;
    int i, count = 0;
    
    if (intersect_objects(origin, dir, info)) {
        return materials[info.material_idx].ambient;
    }

    return vec4(0.0, 0.0, 0.0, 0.0);
}

void main() 
{
    materials[0].ambient = vec4(1.0, 0.0, 0.0, 1.0);
    materials[1].ambient = vec4(0.0, 1.0, 0.0, 1.0);
    materials[2].ambient = vec4(0.0, 0.0, 1.0, 1.0);

    // get index in global work group i.e x,y position
    ivec2 pixel_coords = ivec2(gl_GlobalInvocationID.xy);
    vec2 pos = pixel_coords / 512.0;
    vec3 dir = mix(mix(ray00, ray01, pos.y), mix(ray10, ray11, pos.y), pos.x);
    vec4 pixel;
    pixel = trace(eye, dir);
    imageStore(framebuffer, pixel_coords, pixel);
}

// Reference : 
// https://github.com/LWJGL/lwjgl3-wiki/wiki/2.6.1.-Ray-tracing-with-OpenGL-Compute-Shaders-%28Part-I%29