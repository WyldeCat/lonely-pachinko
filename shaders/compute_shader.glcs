#version 440

#define MAX_NUM_VERTICES  2500
#define MAX_NUM_TRIANGLES 2500
#define MAX_NUM_SPHERES   2500

struct triangle {
    vec3 points[3];
};

struct sphere {
    vec3 pos;
    float r;
};

struct hitinfo {
    vec2 lambda;
    int idx;
};

layout(binding = 0, rgba32f) uniform image2D framebuffer;
// wrriten by compute shader

layout (local_size_x = 1, local_size_y = 1) in;

uniform vec3 vertices[MAX_NUM_VERTICES];
uniform triangle triangles[MAX_NUM_TRIANGLES];
uniform sphere spheres[MAX_NUM_SPHERES];

uniform int num_triangles;
uniform int num_spheres;

uniform vec3 eye;
uniform vec3 ray00;
uniform vec3 ray10;
uniform vec3 ray01;
uniform vec3 ray11;

vec2 intersect_triangle(vec3 origin, vec3 dir, const triangle t)
{
    // TODO : Not implemented
    return vec2(0.0, 0.0);
}

vec2 intersect_sphere(vec3 origin, vec3 dir, const sphere s)
{
    // TODO : Not implemented
    return vec2(0.0, 0.0);
}

bool intersect_objects(vec3 origin, vec3 dir, out hitinfo info)
{
    return true;
}

vec4 trace(vec3 origin, vec3 dir)
{
    hitinfo info;
    int i, count = 0;
    for (i = 0; i < num_triangles; i++) {
        if (vertices[triangles[i].points[0]][0] 
                == vertices[triangles[i].points[1]][1] &&
            triangles[i].points[1] == triangles[i].points[2]) {
            count++;
        }
    }
    for (i = 0; i < num_spheres; i++) {

    }

    return vec4(1.0, 0.0, 0.0, 0.0);
}

void main() 
{
    // get index in global work group i.e x,y position
    ivec2 pixel_coords = ivec2(gl_GlobalInvocationID.xy);
    vec2 pos = pixel_coords / 1024.0;
    vec3 eye_ = eye;
    vec3 dir = mix(mix(ray00, ray01, pos.y), mix(ray10, ray11, pos.y), pos.x);
    vec4 pixel = trace(eye, dir);
    
    imageStore(framebuffer, pixel_coords, pixel);
}

// Reference : https://github.com/LWJGL/lwjgl3-wiki/wiki/2.6.1.-Ray-tracing-with-OpenGL-Compute-Shaders-%28Part-I%29